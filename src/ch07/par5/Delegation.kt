package ch07.par5

/*
* Делегирование - шаблон проектирования, согласно которому объект не сам выполняет требуемое задание, а делегирует его
* другому вспомогательному объекту.
* */
/*
* В общем случае делегирование имеет синтаксис:
* class Foo {
*   var p: Type by Delegate()
* }
*
* свойство p делегирует логику своих методов доступа экземпляру класса Delegate.
* Класс Delegate может быть чем угодно, но должен удовлетворять требованиям соглашения делегирования для свойств.
*
* Компилятор транслирует это объявление в следующее:
* class Foo {
*   private val delegate = Delegate()
*
*   var p: Type
*       set(value: Type) = delegate.setValue(..., value)
*       get() = delegate.getValue(...)
* }
*
* По соглашению делегирования для свойств класс Delegate должен иметь методы getValue (для val и var свойств) и
* setValue (только для var свойств). Как и для всех соглашений эти методы могут быть функциями-расширениями.
*
* class Delegate {
*   operator fun getValue(...) { реализация логики чтения }
*   operator fun setValue(..., value: Type) { реализация логики записи }
* }
* */

/*
* Отложенная (ленивая) инициализация - шаблон, при котором создание объекта откладывается до момента, когда он
* действительно потребуется.
* Пусть класс Person хранит список email-ов, который загружается из БД и мы хотим чтобы адреса извлекались из базы
* только один раз: при первом обращении к свойству.
* */
class Email

fun loadEmails(person: Person): List<Email> {
    println("Loading emails for ${person.name}")
    return listOf(Email())
}
class Person(val name: String) {
    val emails by lazy { loadEmails(this) }
    /*
    * функция lazy возвращает объект Lazy имеющий свойство value (и, соответственно, метод getValue) с соответствующей
    * сигнатурой.
    * lazy потокобезопасен (по умолчанию). Можно дополнительными параметрами указать какую блокировку использовать или
    * не использовать вообще.
    * Lazy инкапсулирует теневое свойство для emails и логику, гарантирующую только однократную его инициализацию.
    * */
}

fun main() {
    val p = Person("Alice")
    p.emails // загрузка адресов при первом обращении
    println(p.emails) // при втором обращении загрузки адресов нет.
}
