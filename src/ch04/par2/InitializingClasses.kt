package ch04.par2

import javax.naming.Context
import javax.swing.text.AttributeSet
import javax.swing.text.SimpleAttributeSet

/*
* Kotlin различает:
* Основной конструктор, который является главным средством инициализации класса и объявляется вне тела касса
* Вторичные конструкторы, которые объявляются в теле класса.
* */

// Простое объявление класса:
class User(val nickname: String)

// фактически при этом (неявно) происходит следующее:
class User1 constructor(_nickname: String) {
    val nickname: String

    init {
        nickname = _nickname
    }
}

/*
* объявление в скобках - это основной конструктор.
* Он содержит перечисление параметров конструктора и они же являются определениями свойств класса, которые
* инициализируются этими параметрами.
*
* ключевое слово constructor отмечает объявление конструктора (основного или вторичного).
* ключевое слово init отмечает блок инициализации.
* Блоки инициализации содержат код инициализации который выполняется при создании каждого экземпляра этого класса.
* блок инициализации используется потому что синтаксис объявления конструктора не включает исполняемого кода.
*
* Можно объявить несколько блоков инициализаци в одном классе.
* */
// равносильный код в java:
/*
class User {
    private final String nickname;

    public User(String _nickname) {
        nickname = _nickname
    }
}
*/
// блок инициализации не содержит специфического кода, а инициализацию можно совместить с объявлением.
// если не используются аннотации / модификаторы доступа, то ключевое слово constructor тоже можно опустить
class User2(_nickname: String) { // объявление класса и основного конструктора
    val nickname = _nickname // объявление и инициализация свойства
}

// ключевое слово val / var в параметрах конструктора укажет компилятору, что для этого параметра нужно создать
// соответствующее свойство (неизменяемое / изменяемое)
class User3(val nickname: String)
// все эти варианты объявления класса эквивалентны.

// параметры конструктора могут иметь значения по умолчанию: тогда при создании объекта передавать значения таких
// параметров становится не обязательно: они будут проинициализированы значениями по умолчанию.
class User4(val nickname: String, val isSubscribed: Boolean = true)

fun main() {
    // создание объекта == вызов конструктора (без new) с передачей обязательных параметров.
    val alice = User4("Alice")
    println("alice.isSubscribed = ${alice.isSubscribed}") // alice.isSubscribed = true
    // при вызове конструктора можно заменить значения по умолчанию, передав новое значение параметра.
    // можно использовать именованные аргументы, как для функций, в любом порядке.
    val bob = User4("Bob", isSubscribed = false)
    println("bob.isSubscribed = ${bob.isSubscribed}") // bob.isSubscribed = false
    /*
    * Для реализации параметров по умолчанию компилятор создаёт несколько перегруженных конструкторов с различным
    * набором аргументов: версия конструктора, не имеющая соответствующего параметра, будет использовать значение по
    * умолчанию.
    * Соответственно, если все свойства имеют значения по умолчанию, компилятор создаст и конструктор без параметров.
    * */
}

/*
* если класс является наследником, он обязан использовать конструктор родителя (чтобы инициализировать унаследованные
* свойства). Для этого он должен указать как и какие параметры своего конструктора нужно использовать в родительском
* конструкторе. Указывается это в скобках после указания, что данный класс наследует родителя.
* */
open class User5(val nickname: String)
class TwitterUser(nickname: String, var account: String) : User5(nickname = nickname) {
    fun doSomething() {}
}
/*
* опять же, можно использовать именованные аргументы
* Здесь nickname для класса TwitterUser - это только параметр конструктора, нового свойства для него не создаётся
* (тем более что есть унаследованное свойство с таким именем). И этот параметр используется только для передачи в
* конструктор родителя
* плюс класс TwitterUser может иметь дополнительные свойства / функции по сравнению с родительским классом
* */

/*
* Если не объявлено никакого конструктора, компилятор создаст конструктор по умолчанию, без аргументов, и который
* ничего не делает.
* */
open class Button {
    // свойство не инициализированное через конструктор обязано быть инициализировано при объявлении или в блоке
    // инициализации
    val text: String

    init {
        text = "dummy"
    }
}

// Но при наследовании вы всё равно будете обязаны явно вызвать этот конструктор
class RadioButton : Button()

// интерфейсы не имеют конструктора, поэтому при наследовании от интерфейса вызывать конструктор не требуется.
interface AbstractButton
class ButtonImplementation : AbstractButton

// возможность создания экземпляров класса можно, как и в java, закрыть, сделав конструктор приватным:
class Secret private constructor() {}

open class View {
    constructor(ctx: Context) {
    }

    constructor(ctx: Context, attr: AttributeSet) {
    }
}

class MyButton : View {
    // делегирование выполнения конструктору этого же класса
    constructor(ctx: Context) : this(ctx, SimpleAttributeSet()) {
    }

    // вызов вторичного конструктора родителя. делегирование
    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {
    }
}