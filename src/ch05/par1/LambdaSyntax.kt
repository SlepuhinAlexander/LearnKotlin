package ch05.par1

/*
* Синтаксис лямбда-выражения:
* { аргумент: ТипАргумента -> тело }
*
* - всё выражение всегда заключено в фигурные скобки
* - аргументов может быть сколько угодно (в т.ч. ноль)
* - аргументы никак не обосабливаются: перечисляются через запятую, отделаются от тела стрелкой.
* - если аргументов нет, стрелку можно опустить
* - тело может состоять из одной или множества инструкций; последняя инструкция считается возвращаемым результатом
* */
fun main() {
    val greeting = { println("I'm lambda!") }
    greeting()
    val sum = { x: Int, y: Int ->
        // лямбда-выражение может содержать сколько угодно выражений или инструкций.
        println("Computing the sum of $x and $y")
        // при этом последнее выражение считается результатом
        x + y
    }
    println(sum(1, 2))
    // функция run выполняет любое лямбда-выражение без аргументов
    run { for (i in 1..10) print(i) }
    // если лямбда-выражение является последним аргументов функции, то его можно вынести за скобки
    // если оно было единственным аргументом функции, то скобки для вызова функции и вовсе не нужны

    val people = listOf(Person("Alice", 29), Person("Bob", 31))
    println(people.joinToString(separator = " ", transform = { it.name }))
    println(people.joinToString(separator = " ") { it.name })
    // если тип параметра можно вывести, нет необходимости указывать его явно
    println(people.maxBy { p -> p.age })
    // если в аргументе ожидается лямбда-выражение с одним параметром, и его тип можно вывести автоматически,
    // то доступно использование имени it для аргумента
    println(people.maxBy { it.age })
    // если лямбда хранится в переменной, то нет контекста, из которого можно вывести тип: его нужно указать явно
    val getAge = { p: Person -> p.age }
}