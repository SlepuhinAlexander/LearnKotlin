package ch09.par1

/*
* Обобщёнными можно объявлять и классы / интерфейсы: необходимо после объявления имени класса / интерфейса указать его
* типовые параметры.
* после этого типовые параметры можно использовать в теле класса (не обязательно только как типовые параметры членов
* класса).
*
* interface List<T> {
*   operator fun get(index: Int): T
* }
*
* Если класс наследует дженерик класс / реализует дженерик интерфейс, нужно указать типовой аргумент родителя: это
* может быть как конкретный тип, так и типовой аргумент:
*
* class StringList : List<String> { ... }
* class ArrayList<T> : List<T> { ... }
*
* типовые параметры класса могут быть ограничены.
* ограничения позволяют сузить круг допустимых для использования типов данных.
* для ОГРАНИЧЕНИЯ СВЕРХУ у типового параметра указывается тип-верхняя-граница через двоеточие
*
* fun <T: Number> List<T>.sum(): T { ... }
*
* Здесь типовой параметр T должен быть типом Number или его наследником.
* Такое ограничение позволяет для типового параметра использовать методы класса, объявленного верхней границей: у
* фактически используемого типового параметра эти методы гарантированно будут.
* */
fun <T : Number> oneHalf(value: T): Double {
    return value.toDouble() / 2.0 // вызов метода Number.toDouble() допустим, т.к. T точно будет Number или наследником
}

/*
* Границей типового параметра может быть любой тип, в том числе и дженерик.
* Например, функция, находящая максимум из своих аргументов: логично, что она может быть применена только к
* сравниваемому типу данных. Это и можно явно указать в объявлении функции.
* */
fun <T : Comparable<T>> maximum(first: T, second: T): T {
    return if (first > second) first else second
    /*
    * оператор first > second компилируется в first.compareTo(second) > 0
    * и такой вызов возможен, т.к. first и second реализуют Comparable
    * */
}

/*
* если нужно указать несколько ограничений, то используется иной синтаксис с ключевым словом where
* */
fun <T> ensureTrailingPeriod(seq: T) where T : Appendable, T : CharSequence {
    if (!seq.endsWith('.')) seq.append('.')
}

/*
* Объявление типового параметра <T> без ограничений равносильно объявлению <T : Any?>:
* т.е. T может быть любым типом данных, причём он nullable.
* соответственно, нужно помнить про безопасные вызовы и т.п.
* */
class Processor<T> {
    fun process(value: T) {
        value?.hashCode() // безопасный вызов hashcode, т.к. value может быть и null
    }
}

/*
* Чтобы гарантировать не-null значения для типового аргумента, то в качестве верхней границы необходимо указать Any
* */
class NullSafeProcessor<T : Any> {
    fun process(value: T) {
        value.hashCode() // безопасных вызов уже не требуется.
    }
}

fun main() {
    println(oneHalf(3)) // 1.5
    println(maximum("kotlin", "java")) // kotlin
    val helloWorld = StringBuilder("Hello World")
    ensureTrailingPeriod(helloWorld)
    println(helloWorld) // Hello World.
}
