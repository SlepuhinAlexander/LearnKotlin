package ch09.par2

/*
* Во время выполнения типовой параметр дженерик класса / функции стирается:
* с точки зрения JVM List<String> и List<Int> - это и то и другое List и сам объект типа List никак не хранит
* использованный типовой параметр.
*
* Соответственно:
* - нельзя проверить к какому типу принадлежит объект: value is List<String> -- не скомпилируется
*
* С помощью синтаксиса проекций можно проверить, что объект действительно является дженерик типом (с каким-то там уже
* неизвестным типовым параметром):
* if (value is List<*>) { ... }
* в некотором смысле это обозначение дженерика с неизвестным типовым аргументом
* List<*> в kotlin аналогично List<?> в java
*
* дженерик типы можно пытаться приводить друг к другу, но при этом в рантайме проверяется только наследование основного
* типа. Даже если типовые параметры несовместимы, приведение типа завершится удачно, т.к. у JVM нет никакой информации
* о типовом параметре.
* */
@Suppress("UNCHECKED_CAST")
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
    /* при приведении типа компилятор выдаст предупреждение: Unchecked cast Collection<*> to List<Int> */
    println(intList.sum())
}

/*
* Компилятор может учесть известную информацию о типовом аргументе
* */
fun printSumSafe(c: Collection<Int>) {
    val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
    /* здесь уже предупреждения не возникает: известно, что типовой параметр совместим */
    println(intList.sum())
}

fun main() {
    // при вызове с List из Int функция отработает корректно
    printSum(listOf(1, 2, 3)) // 6
    // при вызове с другой коллекцией функция отработает тоже корректно: выбросит ожидаемый IllegalArgumentException
    // printSum(setOf(1, 2, 3)) // IllegalArgumentException
    // при вызове с List из несовместимого с Int типа данных функция выбросит ClassCastException
    // printSum(listOf('a', 'b', 'c')) // ClassCastException

    // printSumSafe(listOf('a', 'b', 'c'))
    /* в таком случае компилятор уже не позволит вызвать функцию с аргументом с несовместимым типовым параметром */
}
