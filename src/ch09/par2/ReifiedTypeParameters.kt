package ch09.par2

import java.security.Provider
import java.util.*

/*
* Овеществляемые (reified) типовые параметры
* В общем случае типовые параметры дженериков - затираются, но в Kotlin есть механизм овеществления типовых параметров:
* в таком случае будет возможно сохранить / знать конкретный типовой параметр, который будет использован при вызове
* класса / функции.
* Овеществляемые типовые параметры возможны только в встраиваемых (inline) функциях.
*
* Для указания, что типовой параметр должен овеществляться, перед ним нужно поставить ключевое слово reified
* */
inline fun <reified T> isA(value: Any) = value is T

fun main() {
    println(isA<String>("abc")) // true
    println(isA<String>(123)) // false

    /*
    * пример использования овеществлённых параметров:
    * функция-расширение коллекций filterIsInstance - принимает коллекцию, выбирает из неё экземпляры заданного класса
    * (и наследники) и возвращает только их.
    * */
    val items = listOf("one", 2, 3.0, "four")
    println(items.filterIsInstance<String>()) // [one, four]
    println(items.filterIsInstance<Number>()) // [2, 3.0]

    /*
    * примерный код функции filterIsInstance:
    * inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> {
    *   val destination = mutableListOf()
    *   for (element in this) if (element is T) destination.add(element)
    *   return destination
    * }
    * */
}

/*
* Каждый раз, когда компилятор вставляет байт-код с реализацией inline функции, компилятор точно знает какой тип данных
* используется в качестве типового аргумента при данном конкретном вызове. Поэтому компилятор может овеществить этот
* типовой аргумент: вставить указание на конкретный тип.
*
* Из Java кода вызвать inline функцию с овеществляемым типом невозможно: из Java inline функцию можно вызвать только
* как обычную функцию (без встраивания).
* */

/*
* Овеществляемые типовые параметры можно использовать:
* - в операциях проверки и приведения типов: is, !is, as, as?
* - совместно с рефлексией: ::class
* - для получения соответствующего java.lang.Class: ::class.java
* */

/*
* Чего овеществляемые типы не позволяют делать:
* - создавать новые экземпляры класса, указанного в типовом параметре
* - вызывать методы объекта-компаньона для этого класса
* - использовать неовеществляемый типовой параметр в качестве типового аргумента при вызове функции с овеществляемым
*   типовым параметром
* - объявлять овеществляемыми типовые параметры невстраиваемых функций
* */
