package ch09.par3

/*
* Объявленные in и out типовые параметры дженерик класса - это определение вариантности в месте объявления.
* Указанное объявление вариантности используется везде, где используется типовой параметр в этом классе.
*
* В Java вариантность определяется в месте использования. Kotlin тоже поддерживает эту возможность:
* можно указать вариантность для КОНКРЕТНОГО ВХОЖДЕНИЯ типового параметра, даже если вариантность этого типового
* параметра не была объявлена в классе
* */

fun <T> copyData(
    /*
    * вполне допустимо указать, что параметр T здесь (конкретно здесь) находится во входящей позиции: т.е. что вместо T
    * здесь разрешено использовать подтипы T
    *
    * Такое определение называется ПРОЕКЦИЕЙ ТИПА: оно говорит, что source не обычный MutableList, а его проекция с
    * ограниченными возможностями: source может использовать свой типовой параметр T только в исходящей позиции.
    *
    * Такое объявление <out T> прямо соответствует объявлению в Java <? extends T>
    * */
    source: MutableList<out T>,
    /*
    * Аналогично, можно использовать модификатор in чтобы показать, что типовой параметр потребителя можно заменить
    * любым его супертипом
    *
    * Такое объявление <in T> прямо соответствует объявлению в Java <? super T>
    * */
    destination: MutableList<in T>
) {
    for (item in source) destination.add(item)
}

fun main() {
    val ints = mutableListOf(1, 2, 3)
    val numbers = mutableListOf<Number>()
    val anyItems = mutableListOf<Any>()
    copyData(ints, numbers) // вполне допустимо копировать элементы в коллекцию более общего типа
    println(numbers)
    copyData(ints, anyItems) // вполне допустимо в качестве принимающей коллекции использовать ещё более общий тип
    println(anyItems)
}
