package ch09.par3

/*
* Можно ли в аргумент List<Any> передать объект List<String> ? Безопасно ли это?
* если объект неизменяемый - то безопасно, проблем не будет.
* а если изменяемый, то в другой части кода в объект может быть добавлен / изменён элемент другого типа, не String
* и при попытке работать с коллекцией как со строками приведёт к рантайм исключениям.
* */

/*
* Классы, типы и подтипы
* Класс String может породить как минимум 2 типа данных: String и String?
* List - это класс, но не тип. Он может породить любое количество типов:
* List<Int>, List<String?>, List<List<String>> и т.д.
* (как и любой другой дженерик)
*
* Тип B называется ПОДТИПОМ для типа А, если значение типа B можно использовать везде, где ожидается значение типа А.
* Такой тип А в таком случае называется СУПЕРТИПОМ для типа B.
*
* Любой тип является подтипом самого себя.
*
* Сохранение значения в переменной допускается только тогда, когда тип значения - это подтип типа переменной.
* Передача выражения (значения) в функцию допускается только тогда, когда тип выражения (значения) - это подтип для
* типа параметра функции.
*
* В простых случаях понятие подтипа равносильно понятию подкласса (класса-наследника).
*
* Тип A всегда является подтипом A? (но не наоборот, конечно).
*
* В случае обобщённых классов (дженериков) отношение тип-подтип становятся сложнее.
*
* Обобщённый класс (например, MutableList) называется ИНВАРИАНТНЫМ по типовому параметру, если для любых разных типов
* A и B тип MutableList<A> не является подтипом или супертипом для типа MutableList<B>
*
* В Java все дженерик классы инвариантны по типовому параметру. В Kotlin - не все.
* */

/*
* Ковариантные классы
* Обобщённый (дженерик) класс (например, Producer) называется КОВАРИАНТНЫМ по типовому параметру, если верно следующее:
* Producer<A> является подтипом для типа Producer<B>, если тип A является подтипом для типа B.
*
* Иначе это называется СОХРАНЕНИЕМ НАПРАВЛЕНИЯ ОТНОШЕНИЯ ТИП-ПОДТИП.
*
* Например, Producer<Cat> - это подтип Producer<Animal>, потому что Cat - это подтип Animal.
*
* Чтобы объявить класс ковариантным по типовому параметру, нужно этому параметру указать out
* */
interface Producer<out T> {
    fun produce(): T
}

/*
* Для ковариантного класса можно передавать в аргумент и возвращать из функций тип с более конкретным типовым
* параметром, чем объявленный в классе.
* */
open class Animal {
    fun feed() {
    }
}

class Herd<out T : Animal>(vararg animals: T) {
    private val list = listOf(*animals)
    val size: Int
        get() = list.size

    operator fun get(i: Int): T {
        return list[i]
    }

}

fun feedAll(animals: Herd<Animal>) {
    for (i in 0 until animals.size) animals[i].feed()
}

class Cat : Animal() {
    fun cleanLitter() {
    }
}

fun takeCare(cats: Herd<Cat>) {
    for (i in 0 until cats.size) cats[i].cleanLitter()
    feedAll(cats) // безопасно использовать: Herd ковариантен
}

/*
* Объявление класса ковариантным по типовому параметру накладывает ограничения на использование этого параметра: он
* может быть использован только в ИСХОДЯЩИХ (out) позициях, т.е. класс может только возвращать значения типа T, но не
* потреблять их.
*
* Исходящая позиция (out) - возвращаемые значения функций, использование в качестве типового аргумента в других типах.
* Входящая позиция (in) - используется как аргумент функций.
* Аргументы конструктора не являются ни входящей, ни исходящей позицией.
* Но если аргумент конструктора с val - то вместе с аргументом будет создано свойство -- значит типовой аргумент
* находится в исходящей позиции
* Если аргумент конструктора с var - то, соответственно, типовой аргумент и во входящей, и в исходящей позиции
*
* Правила вариантности имеют значения только для не-приватных членов класса.
* Приватные свойства и методы -- не находятся ни во входящей, ни в исходящей позиции.
* */

/*
* Контрвариантные классы.
* Обобщённый (дженерик) класс (например, Consumer) называется КОНТРВАРИАНТНЫМ по типовому параметру, если верно
* следующее:
* Consumer<A> является подтипом для типа Consumer<B>, если тип B является подтипом для типа A.
*
* Иначе, это ОТНОШЕНИЕ ТИП-ПОДТИП ОБРАТНО НАПРАВЛЕННОЕ.
*
* В контрвариантном классе типовой параметр может находиться только во входящей позиции: т.е. быть аргументом для
* членов класса.
* */
interface Comparator<in T> {
    fun compare(e1: T, e2: T): Int {
        return 0
    }
}
/*
* Реализация этого интерфейса может сравнивать значения любых подтипов к типовому параметру
* */

/*
* Класс может быть ковариантным по одному типовому параметру и контрвариантным по другому.
* Например, интерфейс Function
* (P) -> R
* */
interface Function1<in P, out R> {
    operator fun invoke(p: P): R
}
